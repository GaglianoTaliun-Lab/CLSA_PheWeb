'use strict';

// NOTE: `qval` means `-log10(pvalue)`.

function create_gwas_plot(variant_bins, unbinned_variants, container = '#manhattan_plot_container') {
    // empty the container
    $(container).empty();

    // Order from weakest to strongest pvalue, so that the strongest variant will be on top (z-order) and easily hoverable
    // In the DOM, later siblings are displayed over top of (and occluding) earlier siblings.
    unbinned_variants = _.sortBy(unbinned_variants, function(d){return -d.pval});

    if (variant_bins.length && typeof variant_bins[0].qvals === "undefined") {
        // this json was generated by an old version of pheweb, so we'll manually fix things up.
        variant_bins.forEach(function(bin) {
            bin.qvals = bin.neglog10_pvals;
            bin.qval_extents = bin.neglog10_pval_extents;
        });
    }

    var get_chrom_offsets = _.memoize(function() {
        var chrom_padding = 2e7;
        var chrom_extents = {};

        var update_chrom_extents = function(variant) {
            if (!(variant.chrom in chrom_extents)) {
                chrom_extents[variant.chrom] = [variant.pos, variant.pos];
            } else if (variant.pos > chrom_extents[variant.chrom][1]) {
                chrom_extents[variant.chrom][1] = variant.pos;
            } else if (variant.pos < chrom_extents[variant.chrom][0]) {
                chrom_extents[variant.chrom][0] = variant.pos;
            }
        }
        variant_bins.forEach(update_chrom_extents);
        unbinned_variants.forEach(update_chrom_extents);

        var chroms = _.sortBy(Object.keys(chrom_extents), parseInt);

        var chrom_genomic_start_positions = {};
        chrom_genomic_start_positions[chroms[0]] = 0;
        for (var i=1; i<chroms.length; i++) {
            chrom_genomic_start_positions[chroms[i]] = chrom_genomic_start_positions[chroms[i-1]] + chrom_extents[chroms[i-1]][1] - chrom_extents[chroms[i-1]][0] + chrom_padding;
        }

        // chrom_offsets are defined to be the numbers that make `get_genomic_position()` work.
        // ie, they leave a gap of `chrom_padding` between the last variant on one chromosome and the first on the next.
        var chrom_offsets = {};
        Object.keys(chrom_genomic_start_positions).forEach(function(chrom) {
            chrom_offsets[chrom] = chrom_genomic_start_positions[chrom] - chrom_extents[chrom][0];
        });

        return {
            chrom_extents: chrom_extents,
            chroms: chroms,
            chrom_genomic_start_positions: chrom_genomic_start_positions,
            chrom_offsets: chrom_offsets,
        };
    });

    function get_genomic_position(variant) {
        var chrom_offsets = get_chrom_offsets().chrom_offsets;
        return chrom_offsets[variant.chrom] + variant.pos;
    }

    function get_y_axis_config(max_data_qval, plot_height, includes_pval0) {

        var possible_ticks = [];
        if (max_data_qval <= 14) { possible_ticks = _.range(0, 14.1, 2); }
        else if (max_data_qval <= 28) { possible_ticks = _.range(0, 28.1, 4); }
        else if (max_data_qval <= 40) { possible_ticks = _.range(0, 40.1, 8); }
        else {
            possible_ticks = _.range(0, 20.1, 4);
            if (max_data_qval <= 70) { possible_ticks = possible_ticks.concat([30,40,50,60,70]); }
            else if (max_data_qval <= 120) { possible_ticks = possible_ticks.concat([40,60,80,100,120]); }
            else if (max_data_qval <= 220) { possible_ticks = possible_ticks.concat([60,100,140,180,220]); }
            else {
                var power_of_ten = Math.pow(10, Math.floor(Math.log10(max_data_qval)));
                var first_digit = max_data_qval / power_of_ten;
                var multipliers;
                if (first_digit <= 2) { multipliers = [0.5, 1, 1.5, 2]; }
                else if (first_digit <= 4) { multipliers = [1, 2, 3, 4]; }
                else { multipliers = [2, 4, 6, 8, 10]; }
                possible_ticks = possible_ticks.concat(multipliers.map(function(m) { return m * power_of_ten; }));
            }
        }
        // Include all ticks < qval.  Then also include the next tick.
        // That should mean we'll always have the largest tick >= the largest variant.
        var ticks = possible_ticks.filter(function(qval) { return qval < max_data_qval; });
        if (ticks.length < possible_ticks.length) { ticks.push(possible_ticks[ticks.length]); }

        // Use the largest tick for the top of our y-axis so that we'll have a tick nicely rendered right at the top.
        var max_plot_qval = ticks[ticks.length-1];
        // If we have any qval=inf (pval=0) variants, leave space for them.
        if (includes_pval0) { max_plot_qval *= 1.1 }
        var scale = d3.scaleLinear().clamp(true);
        if (max_plot_qval <= 40) {
            scale = scale
                .domain([max_plot_qval, 0])
                .range([0, plot_height]);
        } else {
            scale = scale
                .domain([max_plot_qval, 20, 0])
                .range([0, plot_height/2, plot_height]);
        }

        if (includes_pval0) { ticks.push(Infinity); }

        return {
            'scale': scale,
            'draw_break_at_20': !(max_plot_qval <= 40),
            'ticks': ticks,
        };
    }

    $(function() {
        var svg_width = $(container).width();
        var svg_height = 400; // shorten plot for manhattan a little bit compared to miami
        var plot_margin = {
            'left': 70,
            'right': 30,
            'top': 20,
            'bottom': 20,
        };
        var plot_width = svg_width - plot_margin.left - plot_margin.right;
        var plot_height = svg_height - plot_margin.top - plot_margin.bottom; 

        var gwas_svg = d3.select(container).append("svg")
            .attr('id', 'gwas_svg')
            .attr("width", svg_width)
            .attr("height", svg_height)
            .style("display", "block")
            .style("margin", "auto");
        var gwas_plot = gwas_svg.append("g")
            .attr('id', 'gwas_plot')
            .attr("transform", fmt("translate({0},{1})", plot_margin.left, plot_margin.top));

        // Significance Threshold line
        var significance_threshold = 5e-8;
        var significance_threshold_tooltip = d3.tip()
            .attr('class', 'd3-tip')
            .html('Significance Threshold: 5E-8')
            .offset([-8,0]);
        gwas_svg.call(significance_threshold_tooltip);

        var genomic_position_extent = (function() {
            var extent1 = d3.extent(variant_bins, get_genomic_position);
            var extent2 = d3.extent(unbinned_variants, get_genomic_position);
            return d3.extent(extent1.concat(extent2));
        })();

        var x_scale = d3.scaleLinear()
            .domain(genomic_position_extent)
            .range([0, plot_width]);

        var includes_pval0 = _.any(unbinned_variants, function(variant) { return variant.pval === 0; });

        var highest_plot_qval = Math.max(
            -Math.log10(significance_threshold) + 0.5,
            (function() {
                var best_unbinned_qval = -Math.log10(d3.min(unbinned_variants, function(d) {
                    return (d.pval === 0) ? 1 : d.pval;
                }));
                if (best_unbinned_qval !== undefined) return best_unbinned_qval;
                return d3.max(variant_bins, function(bin) {
                    return d3.max(bin, _.property('qval'));
                });
            })());

        var y_axis_config = get_y_axis_config(highest_plot_qval, plot_height, includes_pval0);
        var y_scale = y_axis_config.scale;

        // TODO: draw a small y-axis-break at 20 if `y_axis_config.draw_break_at_20`


        var y_axis = d3.axisLeft(y_scale)
            .tickFormat(d3.format("d"))
            .tickValues(y_axis_config.ticks)
        gwas_plot.append("g")
            .attr("class", "y axis")
            .attr('transform', 'translate(-8,0)') // avoid letting points spill through the y axis.
            .call(y_axis);

        if (includes_pval0) {
            var y_axis_break_inf_offset = y_scale(Infinity) + (y_scale(0)-y_scale(Infinity)) * 0.03
            gwas_plot.append('line')
                .attr('x1', -8-7).attr('x2', -8+7)
                .attr('y1', y_axis_break_inf_offset+6).attr('y2', y_axis_break_inf_offset-6)
                .attr('stroke', '#666').attr('stroke-width', '3px');
        }
        if (y_axis_config.draw_break_at_20) {
            var y_axis_break_20_offset = y_scale(20);
            gwas_plot.append('line')
                .attr('x1', -8-7).attr('x2', -8+7)
                .attr('y1', y_axis_break_20_offset+6).attr('y2', y_axis_break_20_offset-6)
                .attr('stroke', '#666').attr('stroke-width', '3px');
        }

        gwas_svg.append('text')
            .style('text-anchor', 'middle')
            .attr('transform', fmt('translate({0},{1})rotate(-90)',
                                   plot_margin.left*.4,
                                   plot_height/2 + plot_margin.top))
            .text('-log\u2081\u2080(p-value)'); // Unicode subscript "10"

        var chroms_and_midpoints = (function() {
            var v = get_chrom_offsets();
            return v.chroms.map(function(chrom) {
                return {
                    chrom: chrom,
                    midpoint: v.chrom_genomic_start_positions[chrom] + (v.chrom_extents[chrom][1] - v.chrom_extents[chrom][0]) / 2,
                };
            });
        })();

        var color_by_chrom = d3.scaleOrdinal()
            .domain(get_chrom_offsets().chroms)
            .range(['rgb(120,120,186)', 'rgb(0,0,66)']);
        //colors to maybe sample from later:
        //.range(['rgb(120,120,186)', 'rgb(0,0,66)', 'rgb(44,150,220)', 'rgb(40,60,80)', 'rgb(33,127,188)', 'rgb(143,76,176)']);

        gwas_svg.selectAll('text.chrom_label')
            .data(chroms_and_midpoints)
            .enter()
            .append('text')
            .style('text-anchor', 'middle')
            .attr('transform', function(d) {
                return fmt('translate({0},{1})',
                           plot_margin.left + x_scale(d.midpoint),
                           plot_height + plot_margin.top + 20);
            })
            .text(function(d) {
                return d.chrom;
            })
            .style('fill', function(d) {
                return color_by_chrom(d.chrom);
            });

        gwas_plot.append('line')
            .attr('x1', 0)
            .attr('x2', plot_width)
            .attr('y1', y_scale(-Math.log10(significance_threshold)))
            .attr('y2', y_scale(-Math.log10(significance_threshold)))
            .attr('stroke-width', '5px')
            .attr('stroke', 'lightgray')
            .attr('stroke-dasharray', '10,10')
            .on('mouseover', significance_threshold_tooltip.show)
            .on('mouseout', significance_threshold_tooltip.hide);

        // Points & labels
        var tooltip_template = _.template(
            window.model.tooltip_underscoretemplate +
                "<% if(_.has(d, 'num_significant_in_peak') && d.num_significant_in_peak>1) { %>#significant variants in peak: <%= d.num_significant_in_peak %><br><% } %>");
        var point_tooltip = d3.tip()
            .attr('class', 'd3-tip')
            .html(function(d) {
                return tooltip_template({d: d});
            })
            .offset([-6,0]);
        gwas_svg.call(point_tooltip);

        function get_link_to_LZ(variant) {
            return fmt(window.model.urlprefix + '/region/{0}/{1}:{2}-{3}',
                       window.phenocode,
                       variant.chrom,
                       Math.max(0, variant.pos - 200*1000),
                       variant.pos + 200*1000);
        }

        // TODO: if the label touches any circles or labels, skip it?
        var variants_to_label = _.sortBy(_.where(unbinned_variants, {peak: true}), _.property('pval'))
            .filter(function(d) { return d.pval < 5e-8; })
            .slice(0,7);

        var genenames = gwas_plot.append('g')
            .attr('class', 'genenames')
            .selectAll('text.genenames')
            .data(variants_to_label)
            .enter()
            .append('text')
            .attr('class', 'genename_text')
            .style('font-style', 'italic')
            .attr('text-anchor', 'middle')
            .attr('transform', function(d) {
                return fmt('translate({0},{1})',
                           x_scale(get_genomic_position(d)),
                           y_scale(-Math.log10(d.pval))-5);
            })
            .text(function(d) {
                if (d.nearest_genes.split(',').length <= 2) {
                    return d.nearest_genes;
                } else {
                    return d.nearest_genes.split(',').slice(0,2).join(',')+',...';
                }
            });

        function pp1() {
        gwas_plot.append('g')
            .attr('class', 'variant_hover_rings')
            .selectAll('a.variant_hover_ring')
            .data(unbinned_variants)
            .enter()
            .append('a')
            .attr('class', 'variant_hover_ring')
            .attr('xlink:href', get_link_to_LZ)
            .append('circle')
            .attr('cx', function(d) {
                return x_scale(get_genomic_position(d));
            })
            .attr('cy', function(d) {
                return y_scale(-Math.log10(d.pval));
            })
            .attr('r', 7)
            .style('opacity', 0)
            .style('stroke-width', 1)
            .on('mouseover', function(d) {
                //Note: once a tooltip has been explicitly placed once, it must be explicitly placed forever after.
                var target_node = document.getElementById(fmt('variant-point-{0}-{1}-{2}-{3}', d.chrom, d.pos, d.ref, d.alt));
                point_tooltip.show(d, target_node);
            })
            .on('mouseout', point_tooltip.hide);
        }
        pp1();

        function pp2() {
        gwas_plot.append('g')
            .attr('class', 'variant_points')
            .selectAll('a.variant_point')
            .data(unbinned_variants)
            .enter()
            .append('a')
            .attr('class', 'variant_point')
            .attr('xlink:href', get_link_to_LZ)
            .append('circle')
            .attr('id', function(d) {
                return fmt('variant-point-{0}-{1}-{2}-{3}', d.chrom, d.pos, d.ref, d.alt);
            })
            .attr('cx', function(d) {
                return x_scale(get_genomic_position(d));
            })
            .attr('cy', function(d) {
                return y_scale(-Math.log10(d.pval));
            })
            .attr('r', 2.3)
            .style('fill', function(d) {
                return color_by_chrom(d.chrom);
            })
            .on('mouseover', function(d) {
                //Note: once a tooltip has been explicitly placed once, it must be explicitly placed forever after.
                point_tooltip.show(d, this);
            })
            .on('mouseout', point_tooltip.hide);
        }
        pp2();

        function pp3() { // drawing the ~60k binned variant circles takes ~500ms.  The (far fewer) unbinned variants take much less time.
        var bins = gwas_plot.append('g')
            .attr('class', 'bins')
            .selectAll('g.bin')
            .data(variant_bins)
            .enter()
            .append('g')
            .attr('class', 'bin')
            .attr('data-index', function(d, i) { return i; }) // make parent index available from DOM
            .each(function(d) { //todo: do this in a forEach
                d.x = x_scale(get_genomic_position(d));
                d.color = color_by_chrom(d.chrom);
            });
        bins.selectAll('circle.binned_variant_point')
            .data(_.property('qvals'))
            .enter()
            .append('circle')
            .attr('class', 'binned_variant_point')
            .attr('cx', function(d, i) {
                var parent_i = +this.parentNode.getAttribute('data-index');
                return variant_bins[parent_i].x;
            })
            .attr('cy', function(qval) {
                return y_scale(qval);
            })
            .attr('r', 2.3)
            .style('fill', function(d, i) {
                var parent_i = +this.parentNode.getAttribute('data-index');
                return variant_bins[parent_i].color;
            });
        bins.selectAll('circle.binned_variant_line')
            .data(_.property('qval_extents'))
            .enter()
            .append('line')
            .attr('class', 'binned_variant_line')
            .attr('x1', function(d, i) {
                var parent_i = +this.parentNode.getAttribute('data-index');
                return variant_bins[parent_i].x;
            })
            .attr('x2', function(d, i) {
                const parent_i = +this.parentNode.getAttribute('data-index');
                return variant_bins[parent_i].x;
            })
            .attr('y1', function(d) { return y_scale(d[0]); })
            .attr('y2', function(d) { return y_scale(d[1]); })
            .style('stroke', function(d, i) {
                var parent_i = +this.parentNode.getAttribute('data-index');
                return variant_bins[parent_i].color;
            })
            .style('stroke-width', 4.6)
            .style('stroke-linecap', 'round');
        }
        pp3();

    });
}

function create_miami_plot(variant_bins1, variant_unbinned1, variant_bins2, variant_unbinned2, label1 = "Data 1", label2 = "Data 2", container = '#manhattan_plot_container'){
    $(container).empty();

    // Order from weakest to strongest pvalue, so that the strongest variant will be on top (z-order) and easily hoverable
    // In the DOM, later siblings are displayed over top of (and occluding) earlier siblings.
    variant_unbinned1 = _.sortBy(variant_unbinned1, function(d){return -d.pval});
    variant_unbinned2 = _.sortBy(variant_unbinned2, function(d){return -d.pval})
    
    if (variant_bins1 != null){

        if (variant_bins1.length && typeof variant_bins1[0].qvals === "undefined") {
            // this json was generated by an old version of pheweb, so we'll manually fix things up.
            variant_bins1.forEach(function(bin) {
                bin.qvals = bin.neglog10_pvals;
                bin.qval_extents = bin.neglog10_pval_extents;
            });
        }
        var get_chrom_offsets_data1 = _.memoize(function() {
            var chrom_padding = 2e7;
            var chrom_extents = {};
    
            var update_chrom_extents = function(variant) {
                if (!(variant.chrom in chrom_extents)) {
                    chrom_extents[variant.chrom] = [variant.pos, variant.pos];
                } else if (variant.pos > chrom_extents[variant.chrom][1]) {
                    chrom_extents[variant.chrom][1] = variant.pos;
                } else if (variant.pos < chrom_extents[variant.chrom][0]) {
                    chrom_extents[variant.chrom][0] = variant.pos;
                }
            }
            variant_bins1.forEach(update_chrom_extents);
            variant_unbinned1.forEach(update_chrom_extents);
    
            var chroms = _.sortBy(Object.keys(chrom_extents), parseInt);
    
            var chrom_genomic_start_positions = {};
            chrom_genomic_start_positions[chroms[0]] = 0;
            for (var i=1; i<chroms.length; i++) {
                chrom_genomic_start_positions[chroms[i]] = chrom_genomic_start_positions[chroms[i-1]] + chrom_extents[chroms[i-1]][1] - chrom_extents[chroms[i-1]][0] + chrom_padding;
            }
    
            // chrom_offsets are defined to be the numbers that make `get_genomic_position()` work.
            // ie, they leave a gap of `chrom_padding` between the last variant on one chromosome and the first on the next.
            var chrom_offsets = {};
            Object.keys(chrom_genomic_start_positions).forEach(function(chrom) {
                chrom_offsets[chrom] = chrom_genomic_start_positions[chrom] - chrom_extents[chrom][0];
            });
    
            return {
                chrom_extents: chrom_extents,
                chroms: chroms,
                chrom_genomic_start_positions: chrom_genomic_start_positions,
                chrom_offsets: chrom_offsets,
            };
        });
    }

    if (variant_bins2 != null){
        if (variant_bins2.length && typeof variant_bins2[0].qvals === "undefined") {
            // this json was generated by an old version of pheweb, so we'll manually fix things up.
            variant_bins2.forEach(function(bin) {
                bin.qvals = bin.neglog10_pvals;
                bin.qval_extents = bin.neglog10_pval_extents;
            });
        }
    
        var get_chrom_offsets_data2 = _.memoize(function() {
            var chrom_padding = 2e7;
            var chrom_extents = {};
    
            var update_chrom_extents = function(variant) {
                if (!(variant.chrom in chrom_extents)) {
                    chrom_extents[variant.chrom] = [variant.pos, variant.pos];
                } else if (variant.pos > chrom_extents[variant.chrom][1]) {
                    chrom_extents[variant.chrom][1] = variant.pos;
                } else if (variant.pos < chrom_extents[variant.chrom][0]) {
                    chrom_extents[variant.chrom][0] = variant.pos;
                }
            }
            variant_bins2.forEach(update_chrom_extents);
            variant_unbinned2.forEach(update_chrom_extents);
    
            var chroms = _.sortBy(Object.keys(chrom_extents), parseInt);
    
            var chrom_genomic_start_positions = {};
            chrom_genomic_start_positions[chroms[0]] = 0;
            for (var i=1; i<chroms.length; i++) {
                chrom_genomic_start_positions[chroms[i]] = chrom_genomic_start_positions[chroms[i-1]] + chrom_extents[chroms[i-1]][1] - chrom_extents[chroms[i-1]][0] + chrom_padding;
            }
    
            // chrom_offsets are defined to be the numbers that make `get_genomic_position()` work.
            // ie, they leave a gap of `chrom_padding` between the last variant on one chromosome and the first on the next.
            var chrom_offsets = {};
            Object.keys(chrom_genomic_start_positions).forEach(function(chrom) {
                chrom_offsets[chrom] = chrom_genomic_start_positions[chrom] - chrom_extents[chrom][0];
            });
    
            return {
                chrom_extents: chrom_extents,
                chroms: chroms,
                chrom_genomic_start_positions: chrom_genomic_start_positions,
                chrom_offsets: chrom_offsets,
            };
        });
    }

    function get_genomic_position_data1(variant) {
        var chrom_offsets = get_chrom_offsets_data1().chrom_offsets;
        return chrom_offsets[variant.chrom] + variant.pos;
    }

    function get_genomic_position_data2(variant) {
        var chrom_offsets = get_chrom_offsets_data2().chrom_offsets;
        return chrom_offsets[variant.chrom] + variant.pos;
    }

    function get_y_axis_config(max_data_qval, plot_height, includes_pval0, direction) {

        var possible_ticks = [];
        if (max_data_qval <= 14) { possible_ticks = _.range(0, 14.1, 2); }
        else if (max_data_qval <= 28) { possible_ticks = _.range(0, 28.1, 4); }
        else if (max_data_qval <= 40) { possible_ticks = _.range(0, 40.1, 8); }
        else {
            possible_ticks = _.range(0, 20.1, 4);
            if (max_data_qval <= 70) { possible_ticks = possible_ticks.concat([30,40,50,60,70]); }
            else if (max_data_qval <= 120) { possible_ticks = possible_ticks.concat([40,60,80,100,120]); }
            else if (max_data_qval <= 220) { possible_ticks = possible_ticks.concat([60,100,140,180,220]); }
            else {
                var power_of_ten = Math.pow(10, Math.floor(Math.log10(max_data_qval)));
                var first_digit = max_data_qval / power_of_ten;
                var multipliers;
                if (first_digit <= 2) { multipliers = [0.5, 1, 1.5, 2]; }
                else if (first_digit <= 4) { multipliers = [1, 2, 3, 4]; }
                else { multipliers = [2, 4, 6, 8, 10]; }
                possible_ticks = possible_ticks.concat(multipliers.map(function(m) { return m * power_of_ten; }));
            }
        }
        // Include all ticks < qval.  Then also include the next tick.
        // That should mean we'll always have the largest tick >= the largest variant.
        var ticks = possible_ticks.filter(function(qval) { return qval < max_data_qval; });
        if (ticks.length < possible_ticks.length) { ticks.push(possible_ticks[ticks.length]); }

        // Use the largest tick for the top of our y-axis so that we'll have a tick nicely rendered right at the top.
        var max_plot_qval = ticks[ticks.length-1];
        // If we have any qval=inf (pval=0) variants, leave space for them.
        if (includes_pval0) { max_plot_qval *= 1.1 }
        var scale = d3.scaleLinear().clamp(true);

        if (direction === "upper"){
            if (max_plot_qval <= 40) {
                scale = scale
                    .domain([max_plot_qval, 0])
                    .range([0, plot_height/2]); // divide by 2 for miami
            } else {
                scale = scale
                    .domain([max_plot_qval, 20, 0])
                    .range([0, plot_height/4, plot_height/2]); // divide by x2 for miami
            }
        } else if (direction === "lower"){
            if (max_plot_qval <= 40) {
                scale = scale
                    .domain([max_plot_qval, max_plot_qval * -0.14])
                    .range([plot_height, plot_height/2]); // divide by 2 for miami
            } else {
                scale = scale
                    .domain([max_plot_qval, 20, -1.5])
                    .range([plot_height, plot_height/4, plot_height/2]); // divide by x2 for miami
            }
        }


        if (includes_pval0) { ticks.push(Infinity); }

        return {
            'scale': scale,
            'draw_break_at_20': !(max_plot_qval <= 40),
            'ticks': ticks,
        };
    }

    $(function() {
        var svg_width = $(container).width();
        var svg_height = 550;
        var plot_margin = {
            'left': 70,
            'right': 30,
            'top': 20,
            'bottom': 20, 
        };
        var plot_width = svg_width - plot_margin.left - plot_margin.right;
        var plot_height = svg_height - plot_margin.top - plot_margin.bottom;

        var miami_svg = d3.select(container).append("svg")
            .attr('id', 'miami_svg')
            .attr("width", svg_width)
            .attr("height", svg_height)
            .style("display", "block")
            .style("margin", "auto");
        var miami_plot = miami_svg.append("g")
            .attr('id', 'miami_plot')
            .attr("transform", fmt("translate({0},{1})", plot_margin.left, plot_margin.top));

        // Significance Threshold line
        var significance_threshold = 5e-8;
        var significance_threshold_tooltip = d3.tip()
            .attr('class', 'd3-tip')
            .html('Significance Threshold: 5E-8')
            .offset([-8,0]);
        miami_svg.call(significance_threshold_tooltip);


        // default to data1 if its available.
        if (variant_bins1 != null){
            
            var genomic_position_extent = (function() { 
                var extent1 = d3.extent(variant_bins1, get_genomic_position_data1);
                var extent2 = d3.extent(variant_unbinned1, get_genomic_position_data1);
                return d3.extent(extent1.concat(extent2));
            })();
        }
        else if ( variant_bins2 != null){
            var genomic_position_extent = (function() { 
                var extent1 = d3.extent(variant_bins2, get_genomic_position_data2);
                var extent2 = d3.extent(variant_unbinned2, get_genomic_position_data2);
                return d3.extent(extent1.concat(extent2));
            })();
        }


        var x_scale = d3.scaleLinear()
            .domain(genomic_position_extent)
            .range([0, plot_width]);

        var includes_pval0 = _.any(variant_unbinned1, function(variant) { return variant.pval === 0; }) ||  _.any(variant_unbinned2, function(variant) { return variant.pval === 0; });

        //for y axis stuff, it will differ between data1 and data2, so we need to seperate them
        var highest_plot_qval_data1 = Math.max(
            -Math.log10(significance_threshold) + 0.5,
            (function() {
                var best_unbinned_qval = -Math.log10(d3.min(variant_unbinned1, function(d) {
                    return (d.pval === 0) ? 1 : d.pval;
                }));
                if (best_unbinned_qval !== undefined) return best_unbinned_qval;
                return d3.max(variant_bins1, function(bin) {
                    return d3.max(bin, _.property('qval'));
                });
            })());
        
        var highest_plot_qval_data2 = Math.max(
            -Math.log10(significance_threshold) + 0.5,
            (function() {
                var best_unbinned_qval = -Math.log10(d3.min(variant_unbinned2, function(d) {
                    return (d.pval === 0) ? 1 : d.pval;
                }));
                if (best_unbinned_qval !== undefined) return best_unbinned_qval;
                return d3.max(variant_bins2, function(bin) {
                    return d3.max(bin, _.property('qval'));
                });
            })());

        if (!isNaN(highest_plot_qval_data2) && !isNaN(highest_plot_qval_data1)){
            var max_value = Math.max(highest_plot_qval_data2,highest_plot_qval_data1);
        } else if (isNaN(highest_plot_qval_data1)){
            var max_value = highest_plot_qval_data2
        } else if (isNaN(highest_plot_qval_data2)){
            var max_value = highest_plot_qval_data1
        }

        var y_axis_config_data1 = get_y_axis_config(max_value, plot_height, includes_pval0, "upper");
        var y_scale_data1 = y_axis_config_data1.scale;
        
        var y_axis_config_data2 = get_y_axis_config(max_value, plot_height, includes_pval0, "lower");
        var y_scale_data2 = y_axis_config_data2.scale;

        // TODO: draw a small y-axis-break at 20 if `y_axis_config.draw_break_at_20`

        var y_axis_data1 = d3.axisLeft(y_scale_data1)
            .tickFormat(d3.format("d"))
            .tickValues(y_axis_config_data1.ticks);
        miami_plot.append("g")
            .attr("class", "y axis")
            .attr('transform', 'translate(-8,0)') // avoid letting points spill through the y axis.
            .call(y_axis_data1);

        var y_axis_data2 = d3.axisLeft(y_scale_data2)
            .tickFormat(d3.format("d"))
            .tickValues(y_axis_config_data2.ticks);
        miami_plot.append("g")
            .attr("class", "y axis")
            .attr('transform', 'translate(-8,0)') // avoid letting points spill through the y axis.
            .call(y_axis_data2);

        if (includes_pval0) {
            var y_axis_break_inf_offset_data1 = y_scale_data1(Infinity) + (y_scale_data1(0)-y_scale_data1(Infinity)) * 0.03
            miami_plot.append('line')
                .attr('x1', -8-7).attr('x2', -8+7)
                .attr('y1', y_axis_break_inf_offset_data1+6).attr('y2', y_axis_break_inf_offset_data1-6)
                .attr('stroke', '#666').attr('stroke-width', '3px');

            var y_axis_break_inf_offset_data2 = y_scale_data2(Infinity) + (y_scale_data2(0)-y_scale_data2(Infinity)) * 0.03
            miami_plot.append('line')
                .attr('x1', -8-7).attr('x2', -8+7)
                .attr('y1', y_axis_break_inf_offset_data2+6).attr('y2', y_axis_break_inf_offset_data2-6)
                .attr('stroke', '#666').attr('stroke-width', '3px')
        }
        if (y_axis_config_data1.draw_break_at_20) {
            var y_axis_break_20_offset = y_scale_data1(20);
            miami_plot.append('line')
                .attr('x1', -8-7).attr('x2', -8+7)
                .attr('y1', y_axis_break_20_offset+6).attr('y2', y_axis_break_20_offset-6)
                .attr('stroke', '#666').attr('stroke-width', '3px');
        }
        if (y_axis_config_data2.draw_break_at_20) {
            var y_axis_break_20_offset = y_scale_data2(20);
            miami_plot.append('line')
                .attr('x1', -8-7).attr('x2', -8+7)
                .attr('y1', y_axis_break_20_offset+6).attr('y2', y_axis_break_20_offset-6)
                .attr('stroke', '#666').attr('stroke-width', '3px')
        }

        //side log10(p-value)
        miami_svg.append('text')
            .style('text-anchor', 'middle')
            .attr('transform', fmt('translate({0},{1})rotate(-90)',
                                    plot_margin.left*.4,
                                    plot_height/2 + plot_margin.top))
            .text('-log\u2081\u2080(p-value)'); // Unicode subscript "10"

        var stratification_label1 = label1.split(".")
        var stratification_label2 = label2.split(".")

        stratification_label1.shift()
        stratification_label2.shift()

        miami_svg.append('text')
            .style('text-anchor', 'middle')
            .attr('transform', fmt('translate({0},{1})rotate(-90)',
                                    plot_margin.left*.4,
                                    plot_height / 4 + plot_margin.top))
            .text(stratification_label1.join(" ")); 

        
        miami_svg.append('text')
            .style('text-anchor', 'middle')
            .attr('transform', fmt('translate({0},{1})rotate(-90)',
                                    plot_margin.left*.4,
                                    plot_height * 3 / 4 + plot_margin.top))
            .text(stratification_label2.join(" ")); 

        if ( variant_bins1 != null){
            var chroms_and_midpoints = (function() {
                var v = get_chrom_offsets_data1();
                return v.chroms.map(function(chrom) {
                    return {
                        chrom: chrom,
                        midpoint: v.chrom_genomic_start_positions[chrom] + (v.chrom_extents[chrom][1] - v.chrom_extents[chrom][0]) / 2,
                    };
                });
            })();
            var color_by_chrom = d3.scaleOrdinal()
            .domain(get_chrom_offsets_data1().chroms)
            .range(['rgb(120,120,186)', 'rgb(0,0,66)']);
        } else if ( variant_bins2 != null){
            var chroms_and_midpoints = (function() {
                var v = get_chrom_offsets_data2();
                return v.chroms.map(function(chrom) {
                    return {
                        chrom: chrom,
                        midpoint: v.chrom_genomic_start_positions[chrom] + (v.chrom_extents[chrom][1] - v.chrom_extents[chrom][0]) / 2,
                    };
                });
            })();
            var color_by_chrom = d3.scaleOrdinal()
            .domain(get_chrom_offsets_data2().chroms)
            .range(['rgb(160,20,20)', 'rgb(59,7,7)']);
        }

        //colors to maybe sample from later:
        //.range(['rgb(120,120,186)', 'rgb(0,0,66)', 'rgb(44,150,220)', 'rgb(40,60,80)', 'rgb(33,127,188)', 'rgb(143,76,176)']);

        miami_svg.selectAll('text.chrom_label')
            .data(chroms_and_midpoints)
            .enter()
            .append('text')
            .style('text-anchor', 'middle')
            .attr('transform', function(d) {
                return fmt('translate({0},{1})',
                            plot_margin.left + x_scale(d.midpoint),
                            plot_height/2 + plot_margin.top + 20); // divide by two to have it midway
            })
            .text(function(d) {
                return d.chrom;
            })
            .style('fill', function(d) {
                return color_by_chrom(d.chrom);
            });
        
        if (variant_bins1 != null){

            miami_plot.append('line')
            .attr('x1', 0)
            .attr('x2', plot_width)
            .attr('y1', y_scale_data1(-Math.log10(significance_threshold)))
            .attr('y2', y_scale_data1(-Math.log10(significance_threshold)))
            .attr('stroke-width', '5px')
            .attr('stroke', 'lightgray')
            .attr('stroke-dasharray', '10,10')
            .on('mouseover', significance_threshold_tooltip.show)
            .on('mouseout', significance_threshold_tooltip.hide);
        }

        if ( variant_bins2 != null){

            miami_plot.append('line')
                .attr('x1', 0)
                .attr('x2', plot_width)
                .attr('y1', y_scale_data2(-Math.log10(significance_threshold)))
                .attr('y2', y_scale_data2(-Math.log10(significance_threshold)))
                .attr('stroke-width', '5px')
                .attr('stroke', 'lightgray')
                .attr('stroke-dasharray', '10,10')
                .on('mouseover', significance_threshold_tooltip.show)
                .on('mouseout', significance_threshold_tooltip.hide)
        }

        // Points & labels
        var tooltip_template = _.template(
            window.model.tooltip_underscoretemplate +
                "<% if(_.has(d, 'num_significant_in_peak') && d.num_significant_in_peak>1) { %>#significant variants in peak: <%= d.num_significant_in_peak %><br><% } %>");
        var point_tooltip = d3.tip()
            .attr('class', 'd3-tip')
            .html(function(d) {
                return tooltip_template({d: d});
            })
            .offset([-6,0]);
        miami_svg.call(point_tooltip);

        function get_link_to_LZ_data1(variant) {
            return fmt(window.model.urlprefix + '/region/{0}/{1}:{2}-{3}',
                        label1,
                        variant.chrom,
                        Math.max(0, variant.pos - 200*1000),
                        variant.pos + 200*1000);
        }
        function get_link_to_LZ_data2(variant) {
            return fmt(window.model.urlprefix + '/region/{0}/{1}:{2}-{3}',
                        label2,
                        variant.chrom,
                        Math.max(0, variant.pos - 200*1000),
                        variant.pos + 200*1000);
        }

        // TODO: if the label touches any circles or labels, skip it?
        var variants_to_label_data1 = _.sortBy(_.where(variant_unbinned1, {peak: true}), _.property('pval'))
            .filter(function(d) { return d.pval < 5e-8; })
            .slice(0,7);

        var variants_to_label_data2 = _.sortBy(_.where(variant_unbinned2, {peak: true}), _.property('pval'))
        .filter(function(d) { return d.pval < 5e-8; })
        .slice(0,7);

        var genenames_data1 = miami_plot.append('g')
            .attr('class', 'genenames_data1')
            .selectAll('text.genenames_data1')
            .data(variants_to_label_data1)
            .enter()
            .append('text')
            .attr('class', 'genename_text')
            .style('font-style', 'italic')
            .attr('text-anchor', 'middle')
            .attr('transform', function(d) {
                return fmt('translate({0},{1})',
                            x_scale(get_genomic_position_data1(d)),
                            y_scale_data1(-Math.log10(d.pval))-5);
            })
            .text(function(d) {
                if (d.nearest_genes.split(',').length <= 2) {
                    return d.nearest_genes;
                } else {
                    return d.nearest_genes.split(',').slice(0,2).join(',')+',...';
                }
            });
        
        var genenames_data2 = miami_plot.append('g')
            .attr('class', 'genenames_data2')
            .selectAll('text.genenames_data2')
            .data(variants_to_label_data2)
            .enter()
            .append('text')
            .attr('class', 'genename_text')
            .style('font-style', 'italic')
            .attr('text-anchor', 'middle')
            .attr('transform', function(d) {
                return fmt('translate({0},{1})',
                            x_scale(get_genomic_position_data2(d)),
                            y_scale_data2(-Math.log10(d.pval)) + 20);
            })
            .text(function(d) {
                if (d.nearest_genes.split(',').length <= 2) {
                    return d.nearest_genes;
                } else {
                    return d.nearest_genes.split(',').slice(0,2).join(',')+',...';
                }
            })

        function pp1(flip) {
                if(flip ){
                    miami_plot.append('g')
                    .attr('class', 'variant_hover_rings')
                    .selectAll('a.variant_hover_ring')
                    .data(variant_unbinned2)
                    .enter()
                    .append('a')
                    .attr('class', 'variant_hover_ring')
                    .attr('xlink:href', get_link_to_LZ_data2)
                    .append('circle')
                    .attr('cx', function(d) {
                        return x_scale(get_genomic_position_data2(d));
                    })
                    .attr('cy', function(d) {
                        return y_scale_data2(-Math.log10(d.pval));
                    })
                    .attr('r', 7)
                    .style('opacity', 0)
                    .style('stroke-width', 1)
                    .on('mouseover', function(d) {
                        //Note: once a tooltip has been explicitly placed once, it must be explicitly placed forever after.
                        var target_node = document.getElementById(fmt('variant-point-{0}-{1}-{2}-{3}', d.chrom, d.pos, d.ref, d.alt));
                        point_tooltip.show(d, target_node);
                    })
                    .on('mouseout', point_tooltip.hide)
                } else if (!flip) {
                    miami_plot.append('g')
                    .attr('class', 'variant_hover_rings')
                    .selectAll('a.variant_hover_ring')
                    .data(variant_unbinned1)
                    .enter()
                    .append('a')
                    .attr('class', 'variant_hover_ring')
                    .attr('xlink:href', get_link_to_LZ_data1)
                    .append('circle')
                    .attr('cx', function(d) {
                        return x_scale(get_genomic_position_data1(d));
                    })
                    .attr('cy', function(d) {
                        return y_scale_data1(-Math.log10(d.pval));
                    })
                    .attr('r', 7)
                    .style('opacity', 0)
                    .style('stroke-width', 1)
                    .on('mouseover', function(d) {
                        //Note: once a tooltip has been explicitly placed once, it must be explicitly placed forever after.
                        var target_node = document.getElementById(fmt('variant-point-{0}-{1}-{2}-{3}', d.chrom, d.pos, d.ref, d.alt));
                        point_tooltip.show(d, target_node);
                    })
                    .on('mouseout', point_tooltip.hide);
                }
            }

        if ( variant_bins1 != null){
            pp1(false);
        }
        if (variant_bins2 != null){
            pp1(true);
        }

        //these are where clickable points will be appended to the plot
        function pp2(flip) {
            if(flip ){
                miami_plot.append('g')
                .attr('class', 'variant_points')
                .selectAll('a.variant_point')
                .data(variant_unbinned2)
                .enter()
                .append('a')
                .attr('class', 'variant_point')
                .attr('xlink:href', get_link_to_LZ_data2)
                .append('circle')
                .attr('id', function(d) {
                    return fmt('variant-point-{0}-{1}-{2}-{3}', d.chrom, d.pos, d.ref, d.alt);
                })
                .attr('cx', function(d) {
                    return x_scale(get_genomic_position_data2(d));
                })
                .attr('cy', function(d) {
                    return y_scale_data2(-Math.log10(d.pval));
                })
                .attr('r', 2.3)
                .style('fill', function(d) {
                    return color_by_chrom(d.chrom);
                })
                .on('mouseover', function(d) {
                    //Note: once a tooltip has been explicitly placed once, it must be explicitly placed forever after.
                    point_tooltip.show(d, this);
                })
                .on('mouseout', point_tooltip.hide)
            } else if (!flip ) {
                miami_plot.append('g')
                .attr('class', 'variant_points')
                .selectAll('a.variant_point')
                .data(variant_unbinned1)
                .enter()
                .append('a')
                .attr('class', 'variant_point')
                .attr('xlink:href', get_link_to_LZ_data1)
                .append('circle')
                .attr('id', function(d) {
                    return fmt('variant-point-{0}-{1}-{2}-{3}', d.chrom, d.pos, d.ref, d.alt);
                })
                .attr('cx', function(d) {
                    return x_scale(get_genomic_position_data1(d));
                })
                .attr('cy', function(d) {
                    return y_scale_data1(-Math.log10(d.pval));
                })
                .attr('r', 2.3)
                .style('fill', function(d) {
                    return color_by_chrom(d.chrom);
                })
                .on('mouseover', function(d) {
                    //Note: once a tooltip has been explicitly placed once, it must be explicitly placed forever after.
                    point_tooltip.show(d, this);
                })
                .on('mouseout', point_tooltip.hide); 
            }
        }
        if ( variant_bins1 != null){
            pp2(false);
        }
        if ( variant_bins2 != null){
            pp2(true);
        }

        //this is where the non-clickable points will be
        function pp3(flip) { // drawing the ~60k binned variant circles takes ~500ms.  The (far fewer) unbinned variants take much less time.
            if(flip ) {
                var bins = miami_plot.append('g')
                .attr('class', 'bins')
                .selectAll('g.bin')
                .data(variant_bins2)
                .enter()
                .append('g')
                .attr('class', 'bin')
                .attr('data-index', function(d, i) { return i; }) // make parent index available from DOM
                .each(function(d) { //todo: do this in a forEach
                    d.x = x_scale(get_genomic_position_data2(d));
                    d.color = color_by_chrom(d.chrom);
                });
            bins.selectAll('circle.binned_variant_point')
                .data(_.property('qvals'))
                .enter()
                .append('circle')
                .attr('class', 'binned_variant_point')
                .attr('cx', function(d, i) {
                    var parent_i = +this.parentNode.getAttribute('data-index');
                    return variant_bins2[parent_i].x;
                })
                .attr('cy', function(qval) {
                    return y_scale_data2(qval);
                })
                .attr('r', 2.3)
                .style('fill', function(d, i) {
                    var parent_i = +this.parentNode.getAttribute('data-index');
                    return variant_bins2[parent_i].color;
                })
            bins.selectAll('circle.binned_variant_line')
                .data(_.property('qval_extents'))
                .enter()
                .append('line')
                .attr('class', 'binned_variant_line')
                .attr('x1', function(d, i) {
                    var parent_i = +this.parentNode.getAttribute('data-index');
                    return variant_bins2[parent_i].x;
                })
                .attr('x2', function(d, i) {
                    const parent_i = +this.parentNode.getAttribute('data-index');
                    return variant_bins2[parent_i].x;
                })
                .attr('y1', function(d) { return y_scale_data2(d[0]); })
                .attr('y2', function(d) { return y_scale_data2(d[1]); })
                .style('stroke', function(d, i) {
                    var parent_i = +this.parentNode.getAttribute('data-index');
                    return variant_bins2[parent_i].color;
                })
                .style('stroke-width', 4.6)
                .style('stroke-linecap', 'round')
            } else if (!flip ) {
                var bins = miami_plot.append('g')
                .attr('class', 'bins')
                .selectAll('g.bin')
                .data(variant_bins1)
                .enter()
                .append('g')
                .attr('class', 'bin')
                .attr('data-index', function(d, i) { return i; }) // make parent index available from DOM
                .each(function(d) { //todo: do this in a forEach
                    d.x = x_scale(get_genomic_position_data1(d));
                    d.color = color_by_chrom(d.chrom);
                });
            bins.selectAll('circle.binned_variant_point')
                .data(_.property('qvals'))
                .enter()
                .append('circle')
                .attr('class', 'binned_variant_point')
                .attr('cx', function(d, i) {
                    var parent_i = +this.parentNode.getAttribute('data-index');
                    return variant_bins1[parent_i].x;
                })
                .attr('cy', function(qval) {
                    return y_scale_data1(qval);
                })
                .attr('r', 2.3)
                .style('fill', function(d, i) {
                    var parent_i = +this.parentNode.getAttribute('data-index');
                    return variant_bins1[parent_i].color;
                });
            bins.selectAll('circle.binned_variant_line')
                .data(_.property('qval_extents'))
                .enter()
                .append('line')
                .attr('class', 'binned_variant_line')
                .attr('x1', function(d, i) {
                    var parent_i = +this.parentNode.getAttribute('data-index');
                    return variant_bins1[parent_i].x;
                })
                .attr('x2', function(d, i) {
                    const parent_i = +this.parentNode.getAttribute('data-index');
                    return variant_bins1[parent_i].x;
                })
                .attr('y1', function(d) { return y_scale_data1(d[0]); })
                .attr('y2', function(d) { return y_scale_data1(d[1]); })
                .style('stroke', function(d, i) {
                    var parent_i = +this.parentNode.getAttribute('data-index');
                    return variant_bins1[parent_i].color;
                })
                .style('stroke-width', 4.6)
                .style('stroke-linecap', 'round');
            }
        }
        if ( variant_bins1 != null){
            pp3(false);
        }
        if (variant_bins2 != null){
            pp3(true);
        }
    });
}

function calculate_qq_dimension(combined_data){

    var height = 0
    var width = 0
    var dimensions = [height, width]
    for (var qq_data of combined_data){
        qq_data.by_maf.forEach(function(data){

            //the last one will always be the one to increase the figure size
            var max_height = data.qq.bins[data.qq.bins.length - 1][1]
            var max_width = data.qq.bins[data.qq.bins.length - 1][0]

            if (dimensions[0] < max_height)
                dimensions[0] = max_height;
    
            if (dimensions[1] < max_width)
                dimensions[1] = max_width;
        });

    }

    return dimensions
}

function create_qq_plot(all_data, height = null, width = null) {

        // id with different all data
        all_data.forEach(function(data){
            var type = data.type.replace(/[ .]/g, "_")
            var qq_ci = data.ci;
            var maf_ranges = data.by_maf;

            maf_ranges.forEach(function(maf_range, i) {
                maf_range.color = ['#e66101', '#fdb863', '#b2abd2', '#5e3c99'][i];
            })

            
            if (width == null){
                var exp_max = d3.max(maf_ranges, function(maf_range) {
                    return maf_range.qq.max_exp_qval;
                });
            } else {
                var exp_max = width
            }

            if (height == null){
                // Note: we already removed all observed -log10(pval)s > ceil(exp_max*2) in python, so we can just use the max observed here.
                var obs_max = d3.max(maf_ranges, function(maf_range) {
                    return d3.max(maf_range.qq.bins, function(bin) {
                        return bin[1];
                    });
                });
            } else {
                var obs_max = height
            }

        obs_max = Math.max(obs_max, exp_max);
        obs_max = Math.ceil(obs_max) + 0.01; // The 0.01 makes sure the integer tick will be shown.
    
            // Your D3 code to create the plot here, using svg_width
            var plot_margin = {
                'left': 70,
                'right': 30,
                'top': 10,
                'bottom': 120,
            };

            var svg_width = $("#qq_plot_container_"+type).width();
            var plot_width = svg_width - plot_margin.left - plot_margin.right;
            
            // Size the plot to make things square.  This way, x_scale and y_scale should be exactly equivalent.
            var plot_height = plot_width / exp_max * obs_max;
            var svg_height = plot_height + plot_margin.top + plot_margin.bottom;
    
            // TODO: use a clip path to keep qq_ci below the upper edge
            var qq_svg = d3.select("#qq_plot_container_"+type).append("svg")
                .attr('id', 'qq_svg')
                .attr("width", svg_width)
                .attr("height", svg_height)
                .style("display", "block")
                .style("margin", "auto");
                
            var qq_plot = qq_svg.append("g")
                .attr('id', 'qq_plot')
                .attr("transform", fmt("translate({0},{1})", plot_margin.left, plot_margin.top));
    
            var x_scale = d3.scaleLinear()
                .domain([0, exp_max])
                .range([0, plot_width]);
            var y_scale = d3.scaleLinear()
                .domain([0, obs_max])
                .range([plot_height, 0]);
    
            // "trumpet" CI path
            qq_plot.append('path')
                .attr('class', 'trumpet_ci')
                .datum(qq_ci)
                .attr("d", d3.area()
                    .x( function(d) {
                        return x_scale(d.x);
                    }).y0( function(d) {
                        return y_scale(d.y_max + .05)
                    }).y1( function(d) {
                        return y_scale(Math.max(0, d.y_min - .05));
                    }))
                .style("fill", "lightgray");
    
            // points
            qq_plot.append('g')
                .selectAll('g.qq_points')
                .data(maf_ranges)
                .enter()
                .append('g')
                .attr('data-index', function(d, i) { return i; }) // make parent index available from DOM
                .attr('class', 'qq_points')
                .selectAll('circle.qq_point')
                .data(function(maf_range) { return maf_range.qq.bins })
                .enter()
                .append('circle')
                .attr('cx', function(d) { return x_scale(d[0]); })
                .attr('cy', function(d) { return y_scale(d[1]); })
                .attr('r', 1.5)
                .attr('fill', function (d, i) {
                    // Nested selections, d3 v4 workaround
                    var parent_index = +this.parentNode.getAttribute('data-index');
                    return maf_ranges[parent_index].color;
                });
    
            var attempt_two_decimals = function(x) {
                if (x == 0) return '0';
                if (x >= 0.01) return x.toFixed(2);
                if (x >= 0.001) return x.toFixed(3);
                return x.toExponential(0);
            };

            // Legend
            qq_svg.append('g')
                .attr('transform', fmt('translate({0},{1})',
                                    plot_margin.left + plot_width,
                                    plot_margin.top + plot_height + 70))
                .selectAll('text.legend-items')
                .data(maf_ranges)
                .enter()
                .append('text')
                .attr('text-anchor', 'end')
                .attr('y', function(d,i) {
                    return i + 'em';
                })
                .text(function(d) {
                    return fmt('{0} ≤ MAF < {1} ({2})',
                            attempt_two_decimals(d.maf_range[0]),
                            attempt_two_decimals(d.maf_range[1]),
                            d.count);
                })
                .attr('fill', function(d) {
                    return d.color;
                });
    
            // Axes
            var xAxis = d3.axisBottom(x_scale)
                .tickSizeInner(-plot_height) // this approach to a grid is taken from <http://bl.ocks.org/hunzy/11110940>
                .tickSizeOuter(0)
                .tickPadding(7)
                .tickFormat(d3.format("d")) //integers
                .tickValues(_.range(exp_max)); //prevent unlabeled, non-integer ticks.
            qq_plot.append("g")
                .attr("class", "x axis")
                .attr("transform", fmt("translate(0,{0})", plot_height))
                .call(xAxis);
    
            var y_axis = d3.axisLeft(y_scale)
                .tickSizeInner(-plot_width)
                .tickSizeOuter(0)
                .tickPadding(7)
                .tickFormat(d3.format("d")) //integers
                .tickValues(_.range(obs_max)); //prevent unlabeled, non-integer ticks.
            qq_plot.append("g")
                .attr("class", "y axis")
                .call(y_axis);
    
            qq_svg.append('text')
                .style('text-anchor', 'middle')
                .attr('transform', fmt('translate({0},{1})rotate(-90)',
                                    plot_margin.left*.4,
                                    plot_margin.top + plot_height/2))
                .text('observed -log\u2081\u2080(p)');
    
            qq_svg.append('text')
                .style('text-anchor', 'middle')
                .attr('transform', fmt('translate({0},{1})',
                                    plot_margin.left + plot_width/2,
                                    plot_margin.top + plot_height + 40))
                .text('expected -log\u2081\u2080(p)');
    
        });

}



function populate_streamtable(variants) {
    $(function() {

      var stratified_html = ""
        if ( window.model.stratified){
            Object.keys(variants[0].stratification).forEach(key => {
                $('#stream_table').find('tr').find('th').eq(-1).after('<th>'+ capitalizeFirstLetter(key) +'</th>')
                stratified_html = stratified_html + '<td><%= v.stratification.'+ key +' %> </td>\n'
            });
        }
      $('body').append(getTemplateHTML(stratified_html))


      var data = _.sortBy(_.where(variants, { peak: true }), _.property('pval'));


  
      var template = _.template($('#streamtable-template').html());
      var view = function(variant) {
          return template({v: variant});
      };
      var $found = $('#streamtable-found');
      $found.text(data.length + " total variants");

      
        var callbacks = {
            pagination: function(summary){
                if ($.trim($('#search').val()).length > 0){
                    $found.text(summary.total + " matching variants");
                } else {
                    $found.text(data.length + " total variants");
                }
            }
        }
  
      // Restore pagination state
      var options = {
          view: view,
          search_box: '#search',
          callbacks: callbacks,
          pagination: {
            span: 5,
            next_text: 'Next <span class="glyphicon glyphicon-arrow-right" aria-hidden="true"></span>',
            prev_text: '<span class="glyphicon glyphicon-arrow-left" aria-hidden="true"></span> Previous',
            per_page_select: false,
            per_page: 10,
        }
      }
      $('#stream_table').stream_table(options, data);
  
    });
}

// Define results outside the done function
var manhattan_results = {};  

$(document).ready(function () {  

    // tables
    if (window.model.stratified){

        var promises = phenocode_list.map(function(phenocode) {
            return $.getJSON(window.model.urlprefix + "/api/manhattan/pheno/" + phenocode + ".json");
        });
        
        $.when.apply($, promises).done(function() {
            var combinedResults = [];
            var results = Array.prototype.slice.call(arguments);

            if (phenocode_list.length < 2){
                var processed_results = []
                processed_results.push(results)
            } else {
                var processed_results = results;
            }
        
            processed_results.forEach(function(result, i ) {
                result[0].unbinned_variants.forEach(function(variant) {
                    variant['stratification'] = window.pheno_list[i][phenocode_list[i]].stratification;
                });
                combinedResults = combinedResults.concat(result[0].unbinned_variants);
            });

            populate_streamtable(combinedResults)

        }).fail(function() {
            console.log("One or more requests failed.");
        });

    } else {
        $.getJSON(window.model.urlprefix + "/api/manhattan/pheno/" + window.phenocode + ".json")
        .done(function (data){
          populate_streamtable(data.unbinned_variants);
        }) 
    }

    // manhattan and miami plot generation
    if (window.model.stratified){

        var promises = phenocode_list.map(function(phenocode) {
            return $.getJSON(window.model.urlprefix + "/api/manhattan/pheno/" + phenocode + ".json");
        });
        
        $.when.apply($, promises).done(function() {
            var results = Array.prototype.slice.call(arguments);
            const data_div1 = document.getElementById('dropdown-content-data1');
            const data_div2 = document.getElementById('dropdown-content-data2');

            if (phenocode_list.length < 2){
                var processed_results = []
                processed_results.push(results)
            } else {
                var processed_results = results;
            }

            var sex_stratifications = []
            $('#cases-controls-samples').empty()
            processed_results.forEach((element, index) => {
                sex_stratifications.push(pheno_list[index][phenocode_list[index]].stratification['sex'])
            });

            processed_results.forEach(function(result, i) {

                manhattan_results[phenocode_list[i]] = result[0]
                var data_label = " " + Object.values(pheno_list[i][phenocode_list[i]].stratification).join(", ")

                // populate case controls
                var pheno = pheno_list[i][phenocode_list[i]]

                let sampleText = "";
                console.log(pheno['num_samples'])
                if ('num_controls' in pheno && pheno['num_controls'] != ""){
                    sampleText = pheno.num_cases +` cases, `+ pheno.num_controls +` controls`;
                } else if ('num_samples' in pheno && pheno['num_samples'] != "") {
                    sampleText = pheno.num_samples +` samples`;
                }

                // if sex male there, will go to first, if female there, will default to second.
                // TODO: clean this up
                if ('sex' in pheno_list[i][phenocode_list[i]].stratification && sex_stratifications.length > 1) {
                    var sex = pheno_list[i][phenocode_list[i]].stratification['sex']
                    if (sex_stratifications.includes("male") && sex_stratifications.includes("female")){
                        if (sex == "male") {
                            var radioButton1 = createRadioButton('data1', phenocode_list[i], data_label, sampleText, true);
                            var radioButton2 = createRadioButton('data2', phenocode_list[i], data_label, sampleText);
                        } else if (sex == "female" ) {
                            var radioButton1 = createRadioButton('data1', phenocode_list[i], data_label, sampleText);
                            var radioButton2 = createRadioButton('data2', phenocode_list[i], data_label, sampleText, true);
                        } else {
                            var radioButton1 = createRadioButton('data1', phenocode_list[i], data_label, sampleText);
                            var radioButton2 = createRadioButton('data2', phenocode_list[i], data_label, sampleText);
                        }
                    } else if (sex_stratifications.includes("male")){
                        if (sex == "male") {
                            var radioButton1 = createRadioButton('data1', phenocode_list[i], data_label, sampleText);
                            var radioButton2 = createRadioButton('data2', phenocode_list[i], data_label, sampleText, true);
                        } else {
                            var radioButton1 = createRadioButton('data1', phenocode_list[i], data_label, sampleText, true);
                            var radioButton2 = createRadioButton('data2', phenocode_list[i], data_label, sampleText);
                        }
                    } else if (sex_stratifications.includes("female")){
                        if (sex == "female") {
                            var radioButton1 = createRadioButton('data1', phenocode_list[i], data_label, sampleText);
                            var radioButton2 = createRadioButton('data2', phenocode_list[i], data_label, sampleText, true);
                        } else {
                            var radioButton1 = createRadioButton('data1', phenocode_list[i], data_label, sampleText, true);
                            var radioButton2 = createRadioButton('data2', phenocode_list[i], data_label, sampleText);
                        }
                    }

                    data_div1.appendChild(radioButton1);
                    data_div2.appendChild(radioButton2);

                } else {
                    var radioButton1 = createRadioButton('data1', phenocode_list[i], data_label, sampleText, true);
                    data_div1.appendChild(radioButton1);
                }

            });

            if (processed_results.length == 1){
                var radioButton2 = createRadioButton('data2', "None", "None", "", true);
                data_div2.appendChild(radioButton2);
            } else {
                var radioButton2 = createRadioButton('data2', "None", "None", "", false);
                data_div2.appendChild(radioButton2);
            }

        }).fail(function() {
            console.log("One or more requests failed.");
        });

    } else {
        $.getJSON(window.model.urlprefix + "/api/manhattan/pheno/" + window.phenocode + ".json")
        .done(function(data) {
            window.debug.manhattan = data;
            create_gwas_plot(data.variant_bins, data.unbinned_variants);
        })
        .fail(function() {
          console.log("Manhattan XHR failed");
        });
    }

    // qq plot
    if (window.model.stratified){
        
        var promises = phenocode_list.map(function(phenocode) {
            return $.getJSON(window.model.urlprefix + "/api/qq/pheno/" + phenocode + ".json");
        });

        $.when.apply($, promises).done(function() {
            var qq_results = [];
            var results = Array.prototype.slice.call(arguments);

            if (phenocode_list.length < 2){
                var processed_results = []
                processed_results.push(results)
            } else {
                var processed_results = results;
            }

            processed_results.forEach(function(result, i) {
                var gc = [];
                result[0]['type'] = phenocode_list[i].replace(/[ .]/g, "_")
                var type = result[0]['type']
                _.sortBy(_.pairs(result[0].overall.gc_lambda), function(d) {return -d[0];}).forEach(function(d, j) {
                    var text = 'GC lambda ' + d[0] + ': ' + d[1].toFixed(3);
                    if (j === 0) { text = '<b>' + text + '</b>'; }
                    text = '<br>' + text;
                    gc.push(text)
                  });
                qq_results.push(result[0])

                // Create a new div element
                var qq_plot_div = $('<div>').attr({
                    class: 'pheno-info col-xs-12 col-sm-4 col-md-3 col-lg-3',
                    id: "qq_plot_div_"+type
                }).html('<p>'+type.replace(/[ _]/g, " ")+'</p>');
        
                // Create a new plot div element
                var qq_plot = $('<div>').attr({
                    class: "qq_plot_container",
                    id: "qq_plot_container_"+type
                });
            
                var gc_control_div = $('<p>').attr({
                    id:  "gc_control_div_"+type
                }).html(gc);
                
                qq_plot_div.append(qq_plot);
                qq_plot_div.append(gc_control_div);
                $('#qq_container').append(qq_plot_div);

            });

            var dimensions = calculate_qq_dimension(qq_results);
            create_qq_plot(qq_results, dimensions[0], dimensions[1]);

        }).fail(function() {
            console.log("One or more requests failed.");
        });

    } else {
        $.getJSON(window.model.urlprefix + "/api/manhattan/pheno/" + window.phenocode + ".json")
        .done(function(data) {
            window.debug.manhattan = data;
            create_gwas_plot(data.variant_bins, data.unbinned_variants);
        })
        .fail(function() {
          console.log("Manhattan XHR failed");
        });
    }

    // Optionally populate a table of correlated phenotypes.
    if (window.model.show_correlations) {
        var corrTable = new Tabulator('#correlations-table', {
            ajaxURL: window.model.correlations_url,
            ajaxResponse: function(url, params, response) {
                return response.data;
            },
            placeholder: 'No correlation data available for this phenotype',
            //layout: 'fitDataFill', // this sizes columns well but doesn't use the full width of the table
            layout: 'fitColumns',
            pagination: 'local',
            paginationSize: 10,
            initialFilter: [ { field: 'pvalue', type: '<', value: window.model.pheno_correlations_pvalue_threshold} ],
            initialSort: [ { column: 'pvalue', dir: 'asc' } ],
            columns: [
                {
                    title: 'Trait', field: 'trait', formatter: 'link',
                    formatterParams: {
                        label: function(cell) { return cell.getData().trait + ': ' + cell.getData().label; },
                        urlPrefix: window.model.urlprefix + '/pheno/'
                    },
                    widthGrow:5, // give all extra space to this column
                },
                { title: 'r<sub>g</sub>', field: 'rg', sorter: 'number' },
                { title: 'SE', field: 'SE', sorter: 'number' },
                { title: 'Z', field: 'Z', sorter: 'number' },
                { title: 'P-value', field: 'pvalue', sorter: 'number' },
                { title: 'Method', field: 'method', headerFilter: true }
            ],
            tooltipGenerationMode: 'hover', // generate tooltips just-in-time when the data is hovered
            tooltips: function(cell) {
                // this function attempts to check whether an ellipsis ('...') is hiding part of the data.
                // to do so, I compare element.clientWidth against element.scrollWidth;
                // when scrollWidth is bigger, that means we're hiding part of the data.
                // unfortunately, the ellipsis sometimes activates too early, meaning that even with clientWidth == scrollWidth some data is hidden by the ellipsis.
                // fortunately, these tooltips are just a convenience so I don't mind if they fail to show.
                // I don't know whether clientWidth or offsetWidth is better. clientWidth was more convenient in Chrome74.
                var e = cell.getElement();
                //return '' + e.offsetWidth + ' || ' + e.scrollWidth + ' || ' + e.clientWidth;
                if (e.clientWidth >= e.scrollWidth) {
                    return false; // all the text is shown, so there is no '...', so no tooltip is needed
                } else if (cell.getColumn().getField() === 'trait') {
                    return cell.getData().trait + ': ' + cell.getData().label; //`e.innerText` could also work
                } else {
                    return cell.getValue();
                }
            }
        });
    }

    //<a class="btn btn-default" href="{{ url_for('.download_pheno', phenocode=phenocode) }}">Download summary statistics</a>


    // append on click listener functionality to download sumstats buttons
    $("#download-all-button").on('click', function () {
        var downloads = []

        // get all phenocodes and append url_for to downloads list
        phenocode_list.forEach(function(phenocode) {
            downloads.push({url: download_url.replace("PHENOCODE_PLACEHOLDER", phenocode), filename: phenocode})
        });

        // TODO: This is extremely hacky.. there needs to be a better way
        console.log(downloads)

        downloads.forEach(function(file) {
            var a = document.createElement('a');
            a.href = file.url;
            a.download = file.filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });
    });

            // Add an event listener to the radio button
    $("#download-current-button").on('click', function () {
        var downloads = []

        // get the values of the labels currently clicked as radio button then append to downloads
        var checkbox_value1 = $('#dropdown-data1 input[type="radio"]:checked').val();
        var checkbox_value2 = $('#dropdown-data2 input[type="radio"]:checked').val();
    
        downloads.push({url: download_url.replace("PHENOCODE_PLACEHOLDER", checkbox_value1), filename: checkbox_value1})
        if (checkbox_value2 != "None"){
            downloads.push({url: download_url.replace("PHENOCODE_PLACEHOLDER", checkbox_value2), filename: checkbox_value2})
        }
        downloads.forEach(function(file) {
            var a = document.createElement('a');
            a.href = file.url;
            a.download = file.filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });
    });
});

var DIR = 'asc';
var LAST_N = 3;
function sortTable(n) {
    var table = document.getElementById("stream_table");

    resetArrows();

    if (LAST_N == n && DIR === 'asc'){
        DIR = "desc";
    } else {
        DIR = "asc";
    }

    // Determine the column name for sorting based on index n
    if (DIR == "desc") {
        table.getElementsByTagName('th')[n].getElementsByClassName('arrow-down')[0].style.borderColor = "grey";
        table.getElementsByTagName('th')[n].getElementsByClassName('arrow-up')[0].style.borderColor = "black";
    } else if (DIR == "asc") {
        table.getElementsByTagName('th')[n].getElementsByClassName('arrow-up')[0].style.borderColor = "grey";
        table.getElementsByTagName('th')[n].getElementsByClassName('arrow-down')[0].style.borderColor = "black";
    }
    LAST_N = n;
}

function resetArrows() {
    var table = document.getElementById("stream_table");
    for (let i = 2; i <= 4; i++) {
        table.getElementsByTagName('th')[i].getElementsByClassName('arrow-up')[0].style.borderColor = "grey";
        table.getElementsByTagName('th')[i].getElementsByClassName('arrow-down')[0].style.borderColor = "grey";
    }
}

function isNumber(str) {
    try {
        const result = new Function(`return ${str}`)();
        return typeof result === 'number' && isFinite(result);
    } catch (e) {
        return false;
    }
}

function evaluateToNumber(str) {
    try {
        const result = new Function(`return ${str}`)();
        if (typeof result === 'number' && isFinite(result)) {
            return result;
        } else {
            return null;
        }
    } catch (e) {
        return null;
    }
}

function getTemplateHTML(stratified_html){
    return($('<div>').html(`
    <script type="text/template" id="streamtable-template">
    <tr>
    <td><a style="color:black" href="{{ url_for('.variant_page', query='').rstrip('/') }}/<%= v.chrom %>-<%= v.pos %>-<%= v.ref %>-<%= v.alt %>">
        <%= v.chrom %>:<%= v.pos.toLocaleString() %> <%= v.ref %> / <%= v.alt %>
        <% if (v.rsids) { %>(<%= v.rsids.replace(/,/g, ', ') %>)<% } %>
    </a></td>
    <td><i><%= v.nearest_genes.replace(/,/g, ', ') %></i></td>
    <td><%= (v.maf)? v.maf.toPrecision(2) : (v.af)? v.af.toPrecision(2):  (v.ac)? v.ac : "" %></td>
    <td><%= (v.pval==0) ? '≤1e-320' : v.pval.toExponential(1) %></td>
    <td><%= (v.beta) ? v.beta.toPrecision(2) : "" %><%= (v.sebeta) ? " ("+v.sebeta.toPrecision(2)+")" : "" %></td>
    <td>NA</td>
    `+
    stratified_html
    +`
    </tr>
    </script>`))
}

function capitalizeFirstLetter(str) {
    if (!str) return str; // Return if the string is empty or null
    return str.charAt(0).toUpperCase() + str.slice(1);
}

// Function to create radio buttons
function createRadioButton(name, value, text, sampleLabel = "", isChecked = false) {

    // Create the label element
    const label = document.createElement('label');
    if (sampleLabel != ""){
        text = text + " (" + sampleLabel + ")";
    }
    label.textContent = text;

    // Create the radio button element
    const radio = document.createElement('input');
    radio.type = 'radio';
    radio.name = name;
    radio.value = value;

    // Set the radio button to checked if isChecked is true
    if (isChecked) {
        radio.checked = true;
        updatePlot()
    }

    // Add an event listener to the radio button
    radio.addEventListener('change', function () {
        if (radio.checked) {
            updatePlot()
        }
    });


    // Append the radio button to the label
    label.prepend(radio);

    return label;
}

function updatePlot() {

        // Start a while loop to wait for the value to become defined
        function checkValue() {
            var checkbox_value1 = $('#dropdown-data1 input[type="radio"]:checked').val();
            var checkbox_value2 = $('#dropdown-data2 input[type="radio"]:checked').val();

            if (checkbox_value1 === undefined || checkbox_value2 === undefined)  {
                setTimeout(checkValue, 100); 
            } else if (checkbox_value1.length < 1 || checkbox_value2 < 1 ) {
                // If value is empty, wait and check again
                setTimeout(checkValue, 100);
            } else {
                // Once the value is defined, execute your code

                var checkbox_value1 = $('#dropdown-data1 input[type="radio"]:checked').val()
                var checkbox_value2 = $('#dropdown-data2 input[type="radio"]:checked').val()

                var checkbox_text1 = $('#dropdown-data1 input[type="radio"]:checked').closest('label').text();
                var checkbox_text2 = $('#dropdown-data2 input[type="radio"]:checked').closest('label').text();

                $('#button-data1').html(`${checkbox_text1}<span class="arrow-container"><span class="arrow-down"></span></span>`);
                $('#button-data2').html(`${checkbox_text2}<span class="arrow-container"><span class="arrow-down"></span></span>`);
        
                if (checkbox_value2 == "None" ){
                    create_gwas_plot(manhattan_results[checkbox_value1]['variant_bins'], manhattan_results[checkbox_value1]['unbinned_variants']);
                } else {
                    var top_value = manhattan_results[checkbox_value1]
                    var bottom_value = manhattan_results[checkbox_value2]
        
                    create_miami_plot(top_value['variant_bins'], top_value['unbinned_variants'], bottom_value['variant_bins'], bottom_value['unbinned_variants'], checkbox_value1, checkbox_value2)
                }            
            }
        }

        checkValue()
}
